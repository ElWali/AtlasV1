<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Atlas.js Lite v0.2</title>
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%; overflow: hidden;
      background: #111;
    }
    #map {
      width: 100%; height: 100%;
      position: relative;
      touch-action: none;
      cursor: grab;
      background: #a4d2e2;
    }
    #map:active { cursor: grabbing; }
    .tile {
      position: absolute;
      width: 256px;
      height: 256px;
      image-rendering: pixelated;
    }
    .marker {
      position: absolute;
      width: 14px; height: 14px;
      background: #ff4757;
      border: 2px solid #fff;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 4px rgba(0,0,0,0.5);
    }
    .attribution {
      position: absolute; bottom: 4px; right: 6px;
      font-size: 11px; color: #ccc; background: rgba(0,0,0,0.5);
      padding: 2px 4px; border-radius: 3px;
      font-family: sans-serif;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <script>
  class AtlasLite {
    constructor(id, options = {}) {
      this.container = document.getElementById(id);
      this.tileSize = 256;
      this.zoom = options.zoom || 5;
      this.center = options.center || { lat: 0, lng: 0 };
      this.url = options.url || 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';
      this.tiles = new Map();
      this.markers = [];
      this.dragging = false;
      this.offsetX = 0;
      this.offsetY = 0;
      this.startDrag = null;
      this.init();
    }

    init() {
      this.layer = document.createElement('div');
      this.layer.style.position = 'absolute';
      this.layer.style.top = '0';
      this.layer.style.left = '0';
      this.container.appendChild(this.layer);

      // Mouse controls
      this.container.addEventListener('mousedown', e => this.onDragStart(e));
      window.addEventListener('mouseup', () => this.onDragEnd());
      window.addEventListener('mousemove', e => this.onDrag(e));
      this.container.addEventListener('wheel', e => this.onZoom(e));

      // Touch controls
      this.container.addEventListener('touchstart', e => this.onTouchStart(e));
      this.container.addEventListener('touchmove', e => this.onTouchMove(e));
      this.container.addEventListener('touchend', e => this.onTouchEnd(e));

      this.render();
    }

    project(lat, lng) {
      const sin = Math.sin(lat * Math.PI / 180);
      const scale = this.tileSize * Math.pow(2, this.zoom);
      const x = (lng + 180) / 360 * scale;
      const y = (0.5 - Math.log((1 + sin) / (1 - sin)) / (4 * Math.PI)) * scale;
      return { x, y };
    }

    unproject(x, y) {
      const scale = this.tileSize * Math.pow(2, this.zoom);
      const lng = (x / scale) * 360 - 180;
      const n = Math.PI - 2 * Math.PI * y / scale;
      const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
      return { lat, lng };
    }

    render() {
      const rect = this.container.getBoundingClientRect();
      const scale = this.tileSize * Math.pow(2, this.zoom);
      const center = this.project(this.center.lat, this.center.lng);
      const startX = center.x - rect.width / 2;
      const startY = center.y - rect.height / 2;

      this.layer.innerHTML = '';
      const startTileX = Math.floor(startX / this.tileSize);
      const startTileY = Math.floor(startY / this.tileSize);
      const endTileX = Math.ceil((startX + rect.width) / this.tileSize);
      const endTileY = Math.ceil((startY + rect.height) / this.tileSize);

      for (let x = startTileX; x <= endTileX; x++) {
        for (let y = startTileY; y <= endTileY; y++) {
          const img = document.createElement('img');
          img.className = 'tile';
          const src = this.url.replace('{z}', this.zoom)
            .replace('{x}', x)
            .replace('{y}', y);
          img.src = src;
          img.style.left = `${x * this.tileSize - startX}px`;
          img.style.top = `${y * this.tileSize - startY}px`;
          this.layer.appendChild(img);
        }
      }

      // Draw markers
      this.markers.forEach(m => this.drawMarker(m.lat, m.lng, rect, center));
      this.showAttribution();
    }

    drawMarker(lat, lng, rect, center) {
      const pos = this.project(lat, lng);
      const div = document.createElement('div');
      div.className = 'marker';
      div.style.left = `${pos.x - (center.x - rect.width / 2)}px`;
      div.style.top = `${pos.y - (center.y - rect.height / 2)}px`;
      this.layer.appendChild(div);
    }

    addMarker(lat, lng) {
      this.markers.push({ lat, lng });
      this.render();
    }

    onDragStart(e) {
      this.dragging = true;
      this.startDrag = { x: e.clientX, y: e.clientY };
      this.startCenter = { ...this.center };
    }

    onDrag(e) {
      if (!this.dragging) return;
      const dx = e.clientX - this.startDrag.x;
      const dy = e.clientY - this.startDrag.y;
      const scale = this.tileSize * Math.pow(2, this.zoom);
      const centerPx = this.project(this.startCenter.lat, this.startCenter.lng);
      const newCenterPx = { x: centerPx.x - dx, y: centerPx.y - dy };
      this.center = this.unproject(newCenterPx.x, newCenterPx.y);
      this.render();
    }

    onDragEnd() {
      this.dragging = false;
    }

    onZoom(e) {
      e.preventDefault();
      const delta = e.deltaY < 0 ? 1 : -1;
      this.zoom = Math.min(19, Math.max(1, this.zoom + delta));
      this.render();
    }

    onTouchStart(e) {
      if (e.touches.length === 1) {
        this.dragging = true;
        this.startDrag = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        this.startCenter = { ...this.center };
      }
    }

    onTouchMove(e) {
      if (this.dragging && e.touches.length === 1) {
        const dx = e.touches[0].clientX - this.startDrag.x;
        const dy = e.touches[0].clientY - this.startDrag.y;
        const scale = this.tileSize * Math.pow(2, this.zoom);
        const centerPx = this.project(this.startCenter.lat, this.startCenter.lng);
        const newCenterPx = { x: centerPx.x - dx, y: centerPx.y - dy };
        this.center = this.unproject(newCenterPx.x, newCenterPx.y);
        this.render();
      }
    }

    onTouchEnd() {
      this.dragging = false;
    }

    showAttribution() {
      const attr = document.createElement('div');
      attr.className = 'attribution';
      attr.textContent = 'Â© OpenStreetMap contributors | Atlas.js Lite v0.2';
      this.layer.appendChild(attr);
    }
  }

  // Demo
  const map = new AtlasLite('map', {
    center: { lat: 31.63, lng: -8.00 }, // Marrakech ðŸ‡²ðŸ‡¦
    zoom: 6
  });

  map.addMarker(33.5731, -7.5898); // Casablanca
  map.addMarker(35.7595, -5.8340); // Tangier
  map.addMarker(31.63, -8.00);     // Marrakech
  </script>
</body>
</html>
